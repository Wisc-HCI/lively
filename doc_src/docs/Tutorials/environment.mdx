# Environment Modeling

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

:::note
Since Lively is still in beta, the design is subject to change and should not be considered final!
:::

<Tabs>
  <TabItem value="jsx" label="Live">

```jsx live
function InitializationExample(props) {
  const [livelySolver, setLivelySolver] = useState(null);
  const [robot, setRobot] = useState("panda");
  const [robotState, setRobotState] = useState(null);
  const [visualRobotState, setVisualRobotState] = useState(null);
  const [transformMode, setTransformMode] = useState("translate");

  const arrowTransformControl = {
    // the visual reresentation for the rotation transform control.
    type: "Arrow",
    name: "arrow transform control",
    frame: "world",
    physical: false,
    localTransform: {
      translation: [0.0, -0.7718020867888795, 0.8679405432017822],
      rotation: [0.0, 0.0, 0.0, 1.0],
    }, // [x, y, z, w] ordering for quaternion
  };

  const sphereTransformControl = {
    // the visual reresentation for the translation transform control.
    type: "Sphere",
    name: "sphere transform control",
    frame: "world",
    radius: 0.05,
    localTransform: {
      translation: [0.0, -0.7718020867888795, 0.8679405432017822],
      rotation: [0.0, 0.0, 0.0, 1.0],
    },
  };

  const [arrowTransformControlVisual, setArrowTransformControlVisual] =
    useState(arrowTransformControl);
  const [sphereTransformControlVisual, setSphereTransformControlVisual] =
    useState(sphereTransformControl);

  const initialGoal = {
    // the inital goal to be fed into the the solver representing the the initial translation and rotation.
    position: {
      Translation: [0.0, -0.7718020867888795, 0.8679405432017822],
    },
    orientation: {
      Rotation: [0.0, 0.0, 0.0, 1.0],
    },
  };

  const [transformControl, setTransformControl] = useState(
    sphereTransformControl
  ); // the visual representation of the transformMode.

  const [goal, setGoal] = useState(initialGoal);

  //console.log("goal" , goal);

  function updateTransformMode() {
    transformMode === "translate"
      ? setTransformMode("rotate")
      : setTransformMode("translate");
    transformControl.type === "Arrow"
      ? setTransformControl(sphereTransformControlVisual)
      : setTransformControl(arrowTransformControlVisual);
  }

  function updateTransform(transform) {
    let newGoal = goal;
    newGoal.position.Translation = [
      transform.position.x,
      transform.position.y,
      transform.position.z,
    ];
    newGoal.orientation.Rotation = [
      transform.quaternion.x,
      transform.quaternion.y,
      transform.quaternion.z,
      transform.quaternion.w,
    ];
    let newArrowTransformControl = arrowTransformControlVisual;
    let newSphereTransformControl = sphereTransformControlVisual;
    newSphereTransformControl.localTransform.translation = [
      transform.position.x,
      transform.position.y,
      transform.position.z,
    ];
    newSphereTransformControl.localTransform.rotation = [
      transform.quaternion.x,
      transform.quaternion.y,
      transform.quaternion.z,
      transform.quaternion.w,
    ];
    newArrowTransformControl.localTransform.translation = [
      transform.position.x,
      transform.position.y,
      transform.position.z,
    ];
    newArrowTransformControl.localTransform.rotation = [
      transform.quaternion.x,
      transform.quaternion.y,
      transform.quaternion.z,
      transform.quaternion.w,
    ];
    setArrowTransformControlVisual(newArrowTransformControl);
    setSphereTransformControlVisual(newSphereTransformControl);
    setGoal(newGoal);
    transformMode === "translate"
      ? setTransformControl(newSphereTransformControl)
      : setTransformControl(newArrowTransformControl);
  }

  const shapes = [
    {
      type: "Box", //can be 'Cylinder', 'Capsule', or 'Sphere'
      name: "box", // name can be arbitrary
      frame: "world", // or 'world'
      physical: true, // physical collision
      x: 0.25,
      y: 0.25,
      z: 0.25, // dimension of the box
      localTransform: {
        translation: [0.6, 0.05, 0.15],
        rotation: [0.0, 0.0, 0.0, 1.0],
      }, // [x, y, z, w] ordering for quaternion
    },
    {
      type: "Capsule",
      name: "pill",
      frame: "world",
      physical: true,
      length: 0.2,
      radius: 0.1,
      localTransform: {
        translation: [-0.5, 0.0, 0.5],
        rotation: [1.0, 0.0, 0.0, 0.0],
      }, // [x, y, z, w] ordering for quaternion
    },
    {
      type: "Cylinder",
      name: "zone",
      frame: "world",
      physical: true,
      length: 0.2,
      radius: 0.1,
      localTransform: {
        translation: [0.0, 0.5, 0.3],
        rotation: [0.0, 0.0, 0.0, 1.0],
      }, // [x, y, z, w] ordering for quaternion
    },
  ];

  useEffect(() => {
    /*
      Given that we are showing this example in a declarative
      react context, we need to use the useEffect hook to execute
      imperative (sequential) code. That means that if you are
      writing standard javascript, your code will look like the
      contents of the "init" function.
      * Note also that the "init" function is async. This is
      because the lively library is built on web assembly (WASM),
      which needs to be imported asynchronously.
      */
    var currentSolver;

    const init = async () => {
      // Initialize the lively package (WASM)
      await lively.init();
      // Instantiate a new solver
      const newSolver = new lively.Solver(
        urdfs.panda, // The urdf of the robot
        {
          // some objective examples. Notice for JavaScript, you do not need to import anything for objective. Simply construct an object
          smoothness: {
            name: "MySmoothnessObjective",
            type: "SmoothnessMacro",
            weight: 0,
            joints: false,
            origin: false,
            links: true,
          },
          collision: {
            name: "MyCollisionDetection",
            type: "CollisionAvoidance",
            weight: 7,
          },
          jointLimit: {
            name: "MyJointLimit",
            type: "JointLimits",
            weight: 5,
          },
          position: {
            name: "MyPositionMatchObjective",
            type: "PositionMatch",
            link: "panda_hand",
            weight: 15,
          },
          orientation: {
            name: "MyOrientationMatchObjective",
            type: "OrientationMatch",
            link: "panda_hand",
            weight: 15,
          },
        },
        [
          { value: 0.0, delta: 0.0 },
          { value: 0.0, delta: 0.0 },
          { value: 0.0, delta: 0.0 }, // Translational
          { value: 0.0, delta: 0.0 },
          { value: 0.0, delta: 0.0 },
          { value: 0.0, delta: 0.0 }, // Rotational
        ],
        shapes
      );
      currentSolver = newSolver; //assign new solver to the current solver in use
      //newSolver.computeAverageDistanceTable();
      // Assign the solver to the value
      setLivelySolver(newSolver);
      // Run solve to get a solved state
      const newState = newSolver.solve(goal, {}, 0.0);

      // Update the solver's current state
      setRobotState(newState);
      setVisualRobotState(newState);
    };
    init();

    const updateSolver = () => {
      if (currentSolver) {
        const d = new Date();
        let time = d.getTime(); // Get the time in milliseconds
        const newState = currentSolver.solve(goal, {}, time / 1000); // Pass the new goal into solve function
        // Update the solver's current state
        setRobotState(newState);
      }
    };

    const interval = setInterval(updateSolver, 1000 / 30); // Update the solver 30fps

    return () => {
      // Provide a function to clear previous values
      setLivelySolver(null);
      setRobotState(null);
      setVisualRobotState(null);
      clearInterval(interval);
    };
  }, [robot]); // Rerun this code if the robot changes

  return (
    <div>
      <RobotViewer
        state={robotState}
        links={livelySolver ? livelySolver.links : []}
        shapes={shapes}
        transformMode={transformMode}
        transformControl={transformControl}
        onMove={(id, source, worldTransform, localTransform) =>
          updateTransform(localTransform)
        }
      />
      <Button
        active={robot === "panda"}
        onClick={() => setVisualRobotState(robotState)}
      >
        Update State
      </Button>
      <Button
        active={transformMode === "translate"}
        onClick={() => updateTransformMode()}
      >
        Position Match
      </Button>
      <Button
        active={transformMode === "rotate"}
        onClick={() => updateTransformMode()}
      >
        Orientation Match
      </Button>
      <Tree label="state" data={visualRobotState} />
    </div>
  );
}
```

  </TabItem>

  <TabItem value="js" label="Javascript">

```js
import init, { Solver } from "lively";

async function start() {
  // Initialize the lively package (WASM)
  await init();
  // Instantiate a new solver
  let solver = new Solver(
    "<?xml version='1.0' ?><robot name='panda'>...</robot>", // Full urdf as a string
    {
      smoothness: {
        // An example objective (smoothness macro)
        name: "MySmoothnessObjective",
        type: "SmoothnessMacro",
        weight: 5,
      },
    }
  );
  // Run solve to get a solved state
  let state = solver.solve({}, {}, 0.0);
  // Log the initial state
  console.log(state);
}

// Could be executed from anywhere that supports async actions
start();
```

  </TabItem>

  <TabItem value="py" label="Python">

```py
from lively import Solver, SmoothnessMacroObjective

# Instantiate a new solver
solver = Solver(
  urdf='<?xml version="1.0" ?><robot name="panda">...</robot>', # Full urdf as a string
  objectives={
      # An example objective (smoothness macro)
      "smoothness":SmoothnessMacroObjective(name="MySmoothnessObjective",weight=5)
  }
)

# Run solve to get a solved state
state = solver.solve({},{},0.0)
# Log the initial state
print(state)
```

  </TabItem>

  <TabItem value="rs" label="Rust">

```rust
use lively::lively::Solver;
use lively::objectives::core::base::SmoothnessMacroObjective;
use lively::objectives::objective::Objective;
use std::collections::HashMap;

// Create a map of objectives
let mut objectives: HashMap<String,Objective> = HashMap::new();
// Add a Smoothness Macro Objective
objectives.insert(
  "smoothness".into(),
  // An example objective (smoothness macro)
  Objective::SmoothnessMacro(SmoothnessMacroObjective::new("MySmoothnessObjective",5.0))
);

// Instantiate a new solver struct
let mut solver = Solver::new(
  urdf:'<?xml version="1.0" ?><robot name="panda">...</robot>', // Full urdf as a string
  objectives
);

// Run solve to get a solved state
let state = solver.solve(
  HashMap::new(),
  HashMap::new(),
  0.0,
  None
);
// Log the initial state
println!("{:?}",state);
```

  </TabItem>

</Tabs>

"use strict";(self.webpackChunklively_documentation=self.webpackChunklively_documentation||[]).push([[5338],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>h});var a=t(67294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,a,o=function(n,e){if(null==n)return{};var t,a,o={},r=Object.keys(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var l=a.createContext({}),u=function(n){var e=a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},c=function(n){var e=u(n.components);return a.createElement(l.Provider,{value:e},n.children)},p="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(n,e){var t=n.components,o=n.mdxType,r=n.originalType,l=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),p=u(t),d=o,h=p["".concat(l,".").concat(d)]||p[d]||m[d]||r;return t?a.createElement(h,i(i({ref:e},c),{},{components:t})):a.createElement(h,i({ref:e},c))}));function h(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var r=t.length,i=new Array(r);i[0]=d;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=n,s[p]="string"==typeof n?n:o,i[1]=s;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},85162:(n,e,t)=>{t.d(e,{Z:()=>i});var a=t(67294),o=t(86010);const r={tabItem:"tabItem_Ymn6"};function i(n){let{children:e,hidden:t,className:i}=n;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r.tabItem,i),hidden:t},e)}},74866:(n,e,t)=>{t.d(e,{Z:()=>g});var a=t(87462),o=t(67294),r=t(86010),i=t(12466),s=t(16550),l=t(91980),u=t(67392),c=t(50012);function p(n){return function(n){return o.Children.map(n,(n=>{if((0,o.isValidElement)(n)&&"value"in n.props)return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(n).map((n=>{let{props:{value:e,label:t,attributes:a,default:o}}=n;return{value:e,label:t,attributes:a,default:o}}))}function m(n){const{values:e,children:t}=n;return(0,o.useMemo)((()=>{const n=e??p(t);return function(n){const e=(0,u.l)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[e,t])}function d(n){let{value:e,tabValues:t}=n;return t.some((n=>n.value===e))}function h(n){let{queryString:e=!1,groupId:t}=n;const a=(0,s.k6)(),r=function(n){let{queryString:e=!1,groupId:t}=n;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l._X)(r),(0,o.useCallback)((n=>{if(!r)return;const e=new URLSearchParams(a.location.search);e.set(r,n),a.replace({...a.location,search:e.toString()})}),[r,a])]}function v(n){const{defaultValue:e,queryString:t=!1,groupId:a}=n,r=m(n),[i,s]=(0,o.useState)((()=>function(n){let{defaultValue:e,tabValues:t}=n;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=t.find((n=>n.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:e,tabValues:r}))),[l,u]=h({queryString:t,groupId:a}),[p,v]=function(n){let{groupId:e}=n;const t=function(n){return n?`docusaurus.tab.${n}`:null}(e),[a,r]=(0,c.Nk)(t);return[a,(0,o.useCallback)((n=>{t&&r.set(n)}),[t,r])]}({groupId:a}),f=(()=>{const n=l??p;return d({value:n,tabValues:r})?n:null})();(0,o.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:i,selectValue:(0,o.useCallback)((n=>{if(!d({value:n,tabValues:r}))throw new Error(`Can't select invalid tab value=${n}`);s(n),u(n),v(n)}),[u,v,r]),tabValues:r}}var f=t(72389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(n){let{className:e,block:t,selectedValue:s,selectValue:l,tabValues:u}=n;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),m=n=>{const e=n.currentTarget,t=c.indexOf(e),a=u[t].value;a!==s&&(p(e),l(a))},d=n=>{let e=null;switch(n.key){case"Enter":m(n);break;case"ArrowRight":{const t=c.indexOf(n.currentTarget)+1;e=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(n.currentTarget)-1;e=c[t]??c[c.length-1];break}}e?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},e)},u.map((n=>{let{value:e,label:t,attributes:i}=n;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:n=>c.push(n),onKeyDown:d,onClick:m},i,{className:(0,r.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":s===e})}),t??e)})))}function S(n){let{lazy:e,children:t,selectedValue:a}=n;if(t=Array.isArray(t)?t:[t],e){const n=t.find((n=>n.props.value===a));return n?(0,o.cloneElement)(n,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},t.map(((n,e)=>(0,o.cloneElement)(n,{key:e,hidden:n.props.value!==a}))))}function w(n){const e=v(n);return o.createElement("div",{className:(0,r.Z)("tabs-container",b.tabList)},o.createElement(y,(0,a.Z)({},n,e)),o.createElement(S,(0,a.Z)({},n,e)))}function g(n){const e=(0,f.Z)();return o.createElement(w,(0,a.Z)({key:String(e)},n))}},12509:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var a=t(87462),o=(t(67294),t(3905)),r=t(74866),i=t(85162);const s={},l="Environment Modeling",u={unversionedId:"Tutorials/environment",id:"Tutorials/environment",title:"Environment Modeling",description:"Since Lively is still in beta, the design is subject to change and should not be considered final!",source:"@site/docs/Tutorials/environment.mdx",sourceDirName:"Tutorials",slug:"/Tutorials/environment",permalink:"/lively/docs/Tutorials/environment",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorials",previous:{title:"Social Robot",permalink:"/lively/docs/Tutorials/social"},next:{title:"Environment Modeling-sine",permalink:"/lively/docs/Tutorials/environment-sine"}},c={},p=[],m={toc:p},d="wrapper";function h(n){let{components:e,...t}=n;return(0,o.kt)(d,(0,a.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"environment-modeling"},"Environment Modeling"),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Since Lively is still in beta, the design is subject to change and should not be considered final!")),(0,o.kt)("p",null,"We have also created examples in Javascript, Python, and Rust for environmental modeling example. You can find the file by clicking the links in the table down below."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Language"),(0,o.kt)("th",{parentName:"tr",align:null},"Path"),(0,o.kt)("th",{parentName:"tr",align:null},"Command to run the example"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Rust"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://github.com/Wisc-HCI/lively/blob/master/examples/rust_examples/environmental_modeling_example.rs"},"link")),(0,o.kt)("td",{parentName:"tr",align:null},"cargo run --package lively --example environmental_modeling_example")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Python"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://github.com/Wisc-HCI/lively/blob/master/examples/python_examples/environmental_example.ipynb"},"link")),(0,o.kt)("td",{parentName:"tr",align:null},"run in the Jupyter Notebook")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Javascript"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("a",{parentName:"td",href:"https://github.com/Wisc-HCI/lively/tree/master/examples/js_examples/environmental"},"link")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"yarn build"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"yarn dev"))))),(0,o.kt)("p",null,"The environmental shapes introduced at the beginning of the solver can be considered as static and cannot be modified. The Cylinder in this example\nis an example of static shape. For more information please see ",(0,o.kt)("a",{parentName:"p",href:"../API/Solver/Methods/solve#shape_update"},(0,o.kt)("inlineCode",{parentName:"a"},"shape_update"))),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"jsx",label:"Live",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function InitializationExample(props) {\n  const initialGoalValues = {\n    // The initial translation of the sphere is at where the gripper is supposed to be at.\n    translation: [\n      -0.35289461347986373, 0.13931635901132902, 0.38946876678037234,\n    ],\n    // The initial rotation is pointing to where the gripper is pointing at.\n    rotation: [\n      0.968947708849441, 0.01867797756065113, -0.2465018112869008,\n      0.005322377470646942,\n    ],\n  };\n\n  const initialState = {\n    origin: {\n      translation: [0.0, 0.0, 0.0],\n      rotation: [0.0, 0.0, 0.0, 1.0],\n    },\n    joints: {\n      shoulder_pan_joint: 3.054197606864953,\n      elbow_joint: -1.2683111703953787,\n      wrist_3_joint: -4.823194599105927,\n      robotiq_85_left_finger_tip_joint: -0.051922213806626316,\n      robotiq_85_right_inner_knuckle_joint: 0.051922213806626316,\n      robotiq_85_right_finger_tip_joint: -0.051922213806626316,\n      shoulder_lift_joint: -1.748886737780085,\n      wrist_1_joint: 5.08275093442812,\n      robotiq_85_left_inner_knuckle_joint: 0.051922213806626316,\n      robotiq_85_right_knuckle_joint: 0.051922213806626316,\n      robotiq_85_left_knuckle_joint: 0.051922213806626316,\n      wrist_2_joint: -4.651476380979644,\n    },\n  };\n\n  const arrowTransformControl = {\n    // the visual reresentation for the rotation transform control.\n    type: "Arrow",\n    name: "arrow transform control",\n    frame: "world",\n    physical: false,\n    localTransform: initialGoalValues,\n  };\n\n  const sphereTransformControl = {\n    // the visual reresentation for the translation transform control.\n    type: "Sphere",\n    name: "sphere transform control",\n    frame: "world",\n    radius: 0.05,\n    localTransform: initialGoalValues,\n  };\n\n  const initialGoal = {\n    // the inital goal to be fed into the the solver representing the the initial translation and rotation.\n    position: {\n      Translation: initialGoalValues.translation,\n    },\n    orientation: {\n      Rotation: initialGoalValues.rotation,\n    },\n  };\n\n  const initialEnvShapes = [\n    {\n      type: "Cylinder", // The Cylinder here is an example of static environmental shape.\n      name: "pill",\n      frame: "world",\n      physical: true,\n      length: 0.3,\n      radius: 0.2,\n      localTransform: {\n        translation: [-0.8, 0.0, 0.1],\n        rotation: [1.0, 0.0, 0.0, 0.0],\n      }, // [x, y, z, w] ordering for quaternion\n    },\n  ];\n\n  const [livelySolver, setLivelySolver] = useState(null);\n  const [robot, setRobot] = useState("panda");\n  const [robotState, setRobotState] = useState(null);\n  const [visualRobotState, setVisualRobotState] = useState(null);\n  const [transformMode, setTransformMode] = useState("translate");\n  const [activeShapesTransform, setShapesTransform] = useState(false);\n  const [arrowTransformControlVisual, setArrowTransformControlVisual] =\n    useState(arrowTransformControl);\n  const [sphereTransformControlVisual, setSphereTransformControlVisual] =\n    useState(sphereTransformControl);\n  const [transformControl, setTransformControl] = useState(\n    sphereTransformControl\n  ); // the visual representation of the transformMode.\n  const [goal, setGoal] = useState(initialGoal);\n  const [envShapes, setEnvShapes] = useState(initialEnvShapes);\n  const [shapesUpdate, setShapesUpdate] = useState(null);\n  const [activeCube, setActiveCube] = useState(false);\n\n  function addOrRemoveEnvCube() {\n    if (activeCube) {\n      const newEnvShapes = envShapes.filter((shape) => shape.name !== "box");\n      setEnvShapes(newEnvShapes);\n      setActiveCube(false);\n      setShapesUpdate([\n        {\n          Delete: "env-box",\n        },\n      ]);\n    } else {\n      const cube = [\n        {\n          Add: {\n            id: "env-box", // must be an unique id\n            shape: {\n              type: "Box", //can be \'Cylinder\', \'Capsule\', or \'Sphere\'\n              name: "box", // name can be arbitrary\n              frame: "world", // or \'world\'\n              physical: true, // physical collision\n              x: 0.25,\n              y: 0.25,\n              z: 0.25, // dimension of the box\n              localTransform: {\n                translation: [0.6, 0.05, 0.15],\n                rotation: [0.0, 0.0, 0.0, 1.0],\n              },\n            },\n          }\n        },\n      ];\n      let newEnvShapes = initialEnvShapes;\n      newEnvShapes.push({\n        type: "Box", //can be \'Cylinder\', \'Capsule\', or \'Sphere\'\n        name: "box", // name can be arbitrary\n        frame: "world", // or \'world\'\n        physical: true, // physical collision\n        x: 0.25,\n        y: 0.25,\n        z: 0.25, // dimension of the box\n        localTransform: {\n          translation: [0.6, 0.05, 0.15],\n          rotation: [0.0, 0.0, 0.0, 1.0],\n        },\n        transformMode : "translate"\n      });\n      setShapesUpdate(cube);\n      setEnvShapes(newEnvShapes);\n      setActiveCube(true);\n    }\n  }\n\n  function updateTransformMode() {\n    // switch between Position Match or Orientation Match\n    transformMode === "translate"\n      ? setTransformMode("rotate")\n      : setTransformMode("translate");\n    transformControl.type === "Arrow"\n      ? setTransformControl(sphereTransformControlVisual)\n      : setTransformControl(arrowTransformControlVisual);\n  }\n\n  function updateTransformControlTransform(transform) {\n    let newGoal = goal;\n    newGoal.position.Translation = [\n      transform.position.x,\n      transform.position.y,\n      transform.position.z,\n    ];\n    newGoal.orientation.Rotation = [\n      transform.quaternion.x,\n      transform.quaternion.y,\n      transform.quaternion.z,\n      transform.quaternion.w,\n    ];\n    let newArrowTransformControl = arrowTransformControlVisual;\n    let newSphereTransformControl = sphereTransformControlVisual;\n    newSphereTransformControl.localTransform.translation = [\n      transform.position.x,\n      transform.position.y,\n      transform.position.z,\n    ];\n    newSphereTransformControl.localTransform.rotation = [\n      transform.quaternion.x,\n      transform.quaternion.y,\n      transform.quaternion.z,\n      transform.quaternion.w,\n    ];\n    newArrowTransformControl.localTransform.translation = [\n      transform.position.x,\n      transform.position.y,\n      transform.position.z,\n    ];\n    newArrowTransformControl.localTransform.rotation = [\n      transform.quaternion.x,\n      transform.quaternion.y,\n      transform.quaternion.z,\n      transform.quaternion.w,\n    ];\n    setArrowTransformControlVisual(newArrowTransformControl); // update the the transformation of the arrow transform control visual in the scene.\n    setSphereTransformControlVisual(newSphereTransformControl); // update the the transformation of the sphere transform control visual in the scene.\n    setGoal(newGoal); // update the goal being sent to the solver.\n    transformMode === "translate"\n      ? setTransformControl(newSphereTransformControl)\n      : setTransformControl(newArrowTransformControl);\n  }\n  // console.log(shapesUpdate);\n  function updateEnvironmentalShapesTransform(id, transform) {\n    let newEnvShapes = envShapes;\n    let newShapeUpdate = null;\n    newEnvShapes.forEach((shape) => {\n      if (id.includes(shape.name)) {\n        shape.localTransform.translation = [\n          transform.position.x,\n          transform.position.y,\n          transform.position.z,\n        ];\n        newShapeUpdate = shape;\n      }\n    });\n    setEnvShapes(newEnvShapes);\n    if (newShapeUpdate) {\n      setShapesUpdate([\n        {\n          Move: {\n            id: "env-box",\n            transform: newShapeUpdate.localTransform,\n          },\n        },\n      ]);\n    }\n  }\n\n  function updateTransform(id, transform) {\n    if (id.includes(`env-shape`)) {\n      updateEnvironmentalShapesTransform(id, transform);\n    } else {\n      updateTransformControlTransform(transform);\n    }\n  }\n\n  useEffect(() => {\n    /*\n      Given that we are showing this example in a declarative\n      react context, we need to use the useEffect hook to execute\n      imperative (sequential) code. That means that if you are\n      writing standard javascript, your code will look like the\n      contents of the "init" function.\n      * Note also that the "init" function is async. This is\n      because the lively library is built on web assembly (WASM),\n      which needs to be imported asynchronously.\n      */\n    var currentSolver;\n\n    // Instantiate a new solver\n    const newSolver = new lively.Solver(\n      urdfs.ur3e, // The urdf of the robot\n      {\n        // some objective examples. Notice for JavaScript, you do not need to import anything for objective. Simply construct an object\n        smoothness: {\n          name: "MySmoothnessObjective",\n          type: "SmoothnessMacro",\n          weight: 15,\n          joints: true,\n          origin: false,\n          links: true,\n        },\n        collision: {\n          // The main objective that allows the robot to avoid collision within the links, as well as with the environmental objects.\n          name: "MyCollisionDetection",\n          type: "CollisionAvoidance",\n          weight: 3,\n        },\n        jointLimit: {\n          name: "MyJointLimit",\n          type: "JointLimits",\n          weight: 5,\n        },\n        position: {\n          // The main objective that allows the pand hand to follow the position defined by the sphere transform control visual in the scene.\n          name: "MyPositionMatchObjective",\n          type: "PositionMatch",\n          link: "tool0",\n          weight: 15,\n        },\n        orientation: {\n          // The main objective that allows the pand hand to follow the orientation defined by the arrow transform control visual in the scene.\n          name: "MyOrientationMatchObjective",\n          type: "OrientationMatch",\n          link: "tool0",\n          weight: 10,\n        },\n      },\n      [\n        { value: 0.0, delta: 0.0 },\n        { value: 0.0, delta: 0.0 },\n        { value: 0.0, delta: 0.0 }, // Translational\n        { value: 0.0, delta: 0.0 },\n        { value: 0.0, delta: 0.0 },\n        { value: 0.0, delta: 0.0 }, // Rotational\n      ],\n      initialEnvShapes, // all the shapes passed in here will be considered as the static environmental shapes. This means that these shapes can not be modified through shapes_update in solve.\n      initialState\n    );\n    newSolver.computeAverageDistanceTable();\n    currentSolver = newSolver; //assign new solver to the current solver in use\n    // Assign the solver to the value\n    setLivelySolver(newSolver);\n    // Run solve to get a solved state\n    const newState = newSolver.solve(goal, {}, 0.0);\n    //console.log(newSolver.updates());\n    // Update the solver\'s current state\n    setRobotState(newState);\n    setVisualRobotState(newState);\n    //setShapesUpdate(shapesUpdate);\n\n    return () => {\n      // Provide a function to clear previous values\n      setLivelySolver(null);\n      setRobotState(null);\n      setVisualRobotState(null);\n      //setShapesUpdate(null);\n      //clearInterval(interval);\n    };\n  }, [robot]); // Rerun this code if the robot changes\n\n  useEffect(() => {\n    const updateSolver = () => {\n      if (livelySolver) {\n        //console.log(shapesUpdate);\n        const d = new Date();\n        let time = d.getTime(); // Get the time in milliseconds\n        const newState = livelySolver.solve(\n          goal,\n          {},\n          time / 1000,\n          shapesUpdate // compare to static environmental shapes, these shapes can be modified.\n        ); // Pass the new goal into solve function\n        // Update the solver\'s current state\n        setRobotState(newState);\n        setVisualRobotState(newState);\n      }\n\n      //console.log(goal);\n    };\n\n    const interval = setInterval(updateSolver, 1000 / 60);\n\n    return (()=>{\n      //setShapesUpdate(null);\n      setRobotState(null);\n      setVisualRobotState(null);\n      clearInterval(interval);\n    })\n  }, [livelySolver,shapesUpdate,goal]); // Update the solver 30fps},[robot])\n\n  return (\n    <div>\n      <RobotViewer\n        state={robotState}\n        links={livelySolver ? livelySolver.links : []}\n        shapes={envShapes}\n        transformMode={transformMode}\n        transformControl={transformControl}\n        onMove={(id, source, worldTransform, localTransform) =>\n          updateTransform(id, localTransform)\n        }\n        activeEnvShapesTransform={activeShapesTransform}\n      />\n      <Button\n        active={robot === "panda"}\n        onClick={() => setVisualRobotState(robotState)}\n      >\n        Update State\n      </Button>\n      <Button\n        active={transformMode === "translate"}\n        onClick={() => updateTransformMode()}\n      >\n        Position Match\n      </Button>\n      <Button\n        active={transformMode === "rotate"}\n        onClick={() => updateTransformMode()}\n      >\n        Orientation Match\n      </Button>\n      <Button active={activeCube} onClick={() => addOrRemoveEnvCube()}>\n        {activeCube\n          ? "Delete environmental shape - Cube"\n          : "Add environmental shape - Cube"}\n      </Button>\n\n      <Tree label="state" data={visualRobotState} />\n    </div>\n  );\n}\n'))),(0,o.kt)(i.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { panda, ur3e } from './urdfs.js';\nimport { Solver } from '@people_and_robots/lively';\n\nconst initialRootBounds = [\n  // An exmaple of root bounds\n  { value: 0.0, delta: 0.0 },\n  { value: 0.25, delta: 0.0 },\n  { value: 0.5, delta: 0.0 },\n  { value: 0.0, delta: 0.0 },\n  { value: 0.0, delta: 0.0 },\n  { value: 0.0, delta: 0.0 },\n];\n\nconst shapeUpdates = [\n  {\n    Add: {\n      id: 'env-box', // must be an unique id\n      shape: {\n        type: 'Box', //can be 'Cylinder', 'Capsule', or 'Sphere'\n        name: 'box', // name can be arbitrary\n        frame: 'world', // or 'world'\n        physical: true, // physical collision\n        x: 0.25,\n        y: 0.25,\n        z: 0.25, // dimension of the box\n        localTransform: {\n          translation: [0.6, 0.05, 0.15],\n          rotation: [0.0, 0.0, 0.0, 1.0],\n        },\n      },\n    },\n  },\n  {\n    Move: {\n      id: 'env-box',\n      transform: {\n        translation: [0.6, 0.05, 0.15],\n        rotation: [0.0, 0.0, 0.0, 1.0],\n      },\n    },\n  },\n  { Delete: 'env-box' },\n];\n\nconst initialObjectives = {\n  // some objective examples. Notice for JavaScript, you do not need to import anything for objective. Simply construct an object\n  smoothness: {\n    name: 'MySmoothnessObjective',\n    type: 'SmoothnessMacro',\n    weight: 15,\n    joints: true,\n    origin: false,\n    links: true,\n  },\n  collision: {\n    // The main objective that allows the robot to avoid collision within the links, as well as with the environmental objects.\n    name: 'MyCollisionDetection',\n    type: 'CollisionAvoidance',\n    weight: 3,\n  },\n  jointLimit: {\n    name: 'MyJointLimit',\n    type: 'JointLimits',\n    weight: 5,\n  },\n  position: {\n    // The main objective that allows the pand hand to follow the position defined by the sphere transform control visual in the scene.\n    name: 'MyPositionMatchObjective',\n    type: 'PositionMatch',\n    link: 'tool0',\n    weight: 15,\n  },\n  orientation: {\n    // The main objective that allows the pand hand to follow the orientation defined by the arrow transform control visual in the scene.\n    name: 'MyOrientationMatchObjective',\n    type: 'OrientationMatch',\n    link: 'tool0',\n    weight: 10,\n  },\n};\n\nconst initialEnvShapes = [\n  {\n    type: 'Cylinder', // The Cylinder here is an example of static environmental shape. This shape will be not able to be moved or deleted.\n    name: 'pill',\n    frame: 'world',\n    physical: true,\n    length: 0.3,\n    radius: 0.2,\n    localTransform: {\n      translation: [-0.8, 0.0, 0.1],\n      rotation: [1.0, 0.0, 0.0, 0.0],\n    }, // [x, y, z, w] ordering for quaternion\n  },\n];\n\nconst collision_settings = {\n  // This is an example of customized collision_settings\n  dMax: 0.1,\n  r: 0.0,\n  aMax: 2.0,\n  timeBudget: 100,\n  timed: false,\n};\n\nconst newSolver = new Solver(\n  ur3e,\n  initialObjectives,\n  initialRootBounds,\n  initialEnvShapes,\n  null,\n  null,\n  null,\n  collision_settings\n);\n\nnewSolver.computeAverageDistanceTable();\nconst d = new Date();\nlet time = d.getTime(); // Get the time used in Math.sin\nlet goal = {\n  // An goal example with defined Scalar and Size values for the lively objectives\n  position: {\n    Translation: [0.6, 0, 0.6],\n  },\n  finger_joint_control: {\n    Scalar: 0.02,\n  },\n  positionLively: {\n    Size: [0.07, 0.05, 0.08],\n  },\n  orientationLively: {\n    Size: [0.07, 0.05, 0.08],\n  },\n  jointLimit: {\n    Scalar: 0.02,\n  },\n};\nconst newState = newSolver.solve(goal, {}, time / 1000, shapeUpdates);\n\ndocument.querySelector('#app').innerHTML = `\n  <div>\n   ${JSON.stringify(newState)}\n  </div>`;\n\nconsole.log(newState);\n\n"))),(0,o.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'from lively import Solver, SmoothnessMacroObjective\n\n# Instantiate a new solver\nsolver = Solver(\n  urdf=\'<?xml version="1.0" ?><robot name="panda">...</robot>\', # Full urdf as a string\n  objectives={\n      # An example objective (smoothness macro)\n      "smoothness":SmoothnessMacroObjective(name="MySmoothnessObjective",weight=5)\n  },\n  root_bounds=[\n      ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0), # Translational, (x, y, z)\n      ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0)  # Rotational, (r, p, y)\n  ],\n  shapes=[\n      BoxShape(name="Table",frame="world",physical=True,x=2,y=1,z=1.2,local_transform=Transform.isometry())\n  ],\n)\nadd_box = BoxShape(name="box_1",frame="world",physical=True,x=1,y=1,z=1.2,local_transform=Transform.isometry())\n# This is an Add ShapeUpdate functionality or type. This introduce a new Cube with "box_1" as the id to the environment.\nshape_update = [pyShapeUpdate.Add(id = "box_1", shape = add_box)]\n# Run solve to get a solved state\nstate = solver.solve(goals = {}, weights = {}, time = 0.0, shape_update = shape_update);\n# Log the initial state\nprint(state)\n'))),(0,o.kt)(i.Z,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use lively::lively::Solver;\nuse lively::objectives::core::base::CollisionAvoidanceObjective;\nuse lively::objectives::core::base::SmoothnessMacroObjective;\nuse lively::objectives::objective::Objective;\nuse lively::utils::info::AddShape;\nuse lively::utils::info::ShapeUpdate;\nuse lively::utils::shapes::*;\nuse nalgebra::geometry::Translation3;\nuse nalgebra::Isometry3;\nuse nalgebra::Quaternion;\nuse nalgebra::UnitQuaternion;\nuse std::collections::HashMap;\nuse std::fs;\n\nfn main() {\n    let mut objectives: HashMap<String, Objective> = HashMap::new();\n    // Add a Smoothness Macro Objective\n    objectives.insert(\n        "smoothness".into(),\n        // An example objective (smoothness macro)\n        Objective::SmoothnessMacro(SmoothnessMacroObjective::new(\n            "MySmoothnessObjective".to_string(),\n            5.0,\n            true,\n            false,\n            false,\n        )),\n    );\n    // Add Collision Avoidance Objective\n    objectives.insert(\n        "collision_avoidance".into(),\n        Objective::CollisionAvoidance(CollisionAvoidanceObjective::new(\n            "MyCollisionAvoidance".to_string(),\n            10.0,\n        )),\n    );\n\n    let iso_1 = Isometry3::from_parts(\n        // defining transform from translation and rotation\n        Translation3::new(\n            1.7497281999999998,\n            -0.24972819999999987,\n            0.050000000000000044,\n        ),\n        UnitQuaternion::from_quaternion(Quaternion::new(\n            0.0,\n            0.0,\n            -0.7069999677447771,\n            0.7072135784958345,\n        )),\n    );\n    //box_1 here is a static environmental shape. This means that box_1 can not be moved or deleted.\n    let box_1 = Shape::Box(BoxShape::new(\n        //can be \'CylinderShape\', \'CapsuleShape\', or \'SphereShape\'\n        "conveyorCollisionShapeBase".to_string(), // name can be arbitrary\n        "world".to_string(),                      // frame name\n        true,                                     // physical collision\n        1.0,                                      // dimension of the box\n        1.1,\n        1.7,\n        iso_1, // local_transform of the box\n    ));\n    let mut box_shapes_vec: Vec<Shape> = vec![box_1];\n    let data =\n        fs::read_to_string("./tests/basic.xml").expect("Something went wrong reading the file");\n    let mut solver = Solver::new(\n        data.clone(),         // Full urdf as a string\n        objectives,           // objectives\n        None,                 //root_bounds\n        Some(box_shapes_vec), //static environmental shapes\n        None,                 // inital_state\n        None,                 //max_retries\n        None,                 //max_iterations\n        None,\n    ); //collision_settings\n\n    let iso_2 = Isometry3::from_parts(\n        Translation3::new(-1.0, 0.5, 2.1),\n        UnitQuaternion::from_quaternion(Quaternion::new(\n            0.0,\n            0.0,\n            -0.7069999677447771,\n            0.7072135784958345,\n        )),\n    );\n    //box_2 here is not a static environmental shape because it will be added to the environment by shape_update\n    let box_2 = Shape::Box(BoxShape::new(\n        "panda_shapebox".to_string(),\n        "world".to_string(),\n        true,\n        1.5,\n        1.7,\n        1.0,\n        iso_2,\n    ));\n\n    // add box_2 to the environment.\n    let add_shape_update = AddShape {\n        id: 1.to_string(), //The id must be unique\n        shape: box_2.clone(),\n    };\n    let shape_update: Vec<ShapeUpdate> = vec![ShapeUpdate::Add(add_shape_update)]; // shape_update\n\n    // Run solve to get a solved state\n    let state = solver.solve(HashMap::new(), HashMap::new(), 0.0, Some(shape_update));\n    // Log the initial state\n    println!("{:?}", state);\n}\n\n')))))}h.isMDXComponent=!0}}]);
"use strict";(self.webpackChunklively_documentation=self.webpackChunklively_documentation||[]).push([[4501],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),r=n(86010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(87462),r=n(67294),i=n(86010),o=n(12466),l=n(16550),s=n(91980),u=n(67392),d=n(50012);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function c(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,l.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=c(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[s,u]=h({queryString:n,groupId:a}),[p,v]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,d.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),b=(()=>{const e=s??p;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{b&&l(b)}),[b]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),v(e)}),[u,v,i]),tabValues:i}}var b=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:n,selectedValue:l,selectValue:s,tabValues:u}=e;const d=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),c=e=>{const t=e.currentTarget,n=d.indexOf(t),a=u[n].value;a!==l&&(p(t),s(a))},m=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>d.push(e),onKeyDown:m,onClick:c},o,{className:(0,i.Z)("tabs__item",f.tabItem,o?.className,{"tabs__item--active":l===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function k(e){const t=v(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",f.tabList)},r.createElement(g,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function N(e){const t=(0,b.Z)();return r.createElement(k,(0,a.Z)({key:String(t)},e))}},22671:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var a=n(87462),r=(n(67294),n(3905)),i=n(74866),o=n(85162);const l={sidebar_position:1},s="Initialization",u={unversionedId:"API/Solver/initialization",id:"API/Solver/initialization",title:"Initialization",description:"Configuring of Lively is centered on the Solver class, which you can instantiate with the following parameters:",source:"@site/docs/API/Solver/initialization.mdx",sourceDirName:"API/Solver",slug:"/API/Solver/initialization",permalink:"/lively/docs/API/Solver/initialization",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"Solver",permalink:"/lively/docs/API/Solver/"},next:{title:"Methods",permalink:"/lively/docs/category/methods"}},d={},p=[{value:"Import",id:"import",level:2},{value:"Example Solver Initialization",id:"example-solver-initialization",level:2}],c={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"initialization"},"Initialization"),(0,r.kt)("p",null,"Configuring of Lively is centered on the ",(0,r.kt)("a",{parentName:"p",href:"../Solver"},(0,r.kt)("inlineCode",{parentName:"a"},"Solver"))," class, which you can instantiate with the following parameters:"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If no values are provided for the ",(0,r.kt)("strong",{parentName:"p"},"optional")," field, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," will just use the default values and behaviors for the optional parameters.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Optional"),(0,r.kt)("th",{parentName:"tr",align:null},"Default value/behavior"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"urdf")),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"URDF XML as a string.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"objectives")),(0,r.kt)("td",{parentName:"tr",align:null},"look-up table of ",(0,r.kt)("a",{parentName:"td",href:"../Objectives"},(0,r.kt)("inlineCode",{parentName:"a"},"Objectives"))," indexed by a string key"),(0,r.kt)("td",{parentName:"tr",align:null},"no"),(0,r.kt)("td",{parentName:"tr",align:null},"none"),(0,r.kt)("td",{parentName:"tr",align:null},"The initial objectives to the ",(0,r.kt)("inlineCode",{parentName:"td"},"Solver"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"root_bounds")),(0,r.kt)("td",{parentName:"tr",align:null},"list of 6 pairs of floats"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"The root of the robot is fixed to the world origin"),(0,r.kt)("td",{parentName:"tr",align:null},"The list of hard limits on how much the base of the robot can move relative to the world frame. The first value in each pair is the center of the range, and the second is the delta allowed. The first 3 entries correspond to the X, Y, and Z coordinates, and the second 3 correspond to the rotation in R, P, Y euler angles")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"shapes")),(0,r.kt)("td",{parentName:"tr",align:null},"list of ",(0,r.kt)("a",{parentName:"td",href:"../Shapes"},(0,r.kt)("inlineCode",{parentName:"a"},"Shape"))," objects"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"There will be no other shapes beside that of the robot."),(0,r.kt)("td",{parentName:"tr",align:null},"The initial environmental shapes that will not be modified in a later stage. ",(0,r.kt)("inlineCode",{parentName:"td"},"shape_update")," in ",(0,r.kt)("a",{parentName:"td",href:"Methods/solve"},(0,r.kt)("inlineCode",{parentName:"a"},"solve"))," will not modify these shapes. They are solely static in the scene.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"initial_state")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"../state"},(0,r.kt)("inlineCode",{parentName:"a"},"State"))," objects"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Only ",(0,r.kt)("inlineCode",{parentName:"td"},"origin")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"joints")," parameters have to be defined for the ",(0,r.kt)("a",{parentName:"td",href:"../state"},(0,r.kt)("inlineCode",{parentName:"a"},"State"))," if user decided to provide a ",(0,r.kt)("a",{parentName:"td",href:"../state"},(0,r.kt)("inlineCode",{parentName:"a"},"State"))," object to the ",(0,r.kt)("inlineCode",{parentName:"td"},"initial_state")," parameter"),(0,r.kt)("td",{parentName:"tr",align:null},"The initial state to the ",(0,r.kt)("inlineCode",{parentName:"td"},"Solver"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"max_retries")),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Value of 1 is used"),(0,r.kt)("td",{parentName:"tr",align:null},"If a value bigger than 1 is provided, the new value is the maximum number of randomly initialized rounds allowed for each invocation of ",(0,r.kt)("a",{parentName:"td",href:"Methods/solve"},(0,r.kt)("inlineCode",{parentName:"a"},"solve")),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"max_iterations")),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"value of 150 is used"),(0,r.kt)("td",{parentName:"tr",align:null},"If a value other than 150 is provided, the value is the number of maximum iterations per round within the optimization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"collision_settings")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"../Info/CollisionSettingInfo"},(0,r.kt)("inlineCode",{parentName:"a"},"Collision Setting"))),(0,r.kt)("td",{parentName:"tr",align:null},"yes"),(0,r.kt)("td",{parentName:"tr",align:null},"See Type Defaults"),(0,r.kt)("td",{parentName:"tr",align:null},"The initial setting to ",(0,r.kt)("a",{parentName:"td",href:"../collision"},(0,r.kt)("inlineCode",{parentName:"a"},"Collision Avoidance")),".")))),(0,r.kt)("h2",{id:"import"},"Import"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { Solver } from "@people_and_robots/lively";\n'))),(0,r.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from lively import Solver\n"))),(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use lively::lively::Solver;\n")))),(0,r.kt)("h2",{id:"example-solver-initialization"},"Example Solver Initialization"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"js",label:"Javascript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { Solver } from "@people_and_robots/lively";\nlet solver = new Solver(\n  (urdf = "<?xml version=\'1.0\' ?><robot name=\'panda\'>...</robot>"), // Full urdf as a string\n  (objectives = {\n    //The initial objectives to the solver\n    eePosition: {\n      type: "PositionMatch", // for Javascript, the type of the objective is the name of the objective but without "Objective". For example, the type for PositionMatchObjective is PositionMatch\n      name: "EE Position", // name can be arbitrary\n      link: "torso",\n      weight: 4, // the weight determines the prioritization of objectives\n    },\n    eeRotation: {\n      type: "OrientationMatch",\n      name: "EE Rotation",\n      link: "torso",\n      weight: 5,\n    },\n    collision: {\n      type: "CollisionAvoidance",\n      name: "Collision Avoidance",\n      weight: 2,\n    },\n  }),\n  (root_bounds = [\n    { value: basePose.position.x, delta: 0.0 },\n    { value: basePose.position.y, delta: 0.0 },\n    { value: basePose.position.z, delta: 0.0 }, // Translational\n    { value: baseEuler[0], delta: 0.0 },\n    { value: baseEuler[1], delta: 0.0 },\n    { value: baseEuler[2], delta: 0.0 }, // Rotational\n  ]),\n  (shapes = [\n    {\n      type: "Box", //can be \'Cylinder\', \'Capsule\', or \'Sphere\'\n      name: "camera attachment", // name can be arbitrary\n      frame: "panda_hand", // or \'world\'\n      physical: true, // physical collision\n      x: 0.5,\n      y: 0.5,\n      z: 0.2, // dimension of the box\n      localTransform: {\n        translation: [0.0, 0.0, 0.0],\n        rotation: [0.0, 0.0, 0.0, 1.0],\n      }, // [x, y, z, w] ordering for quaternion\n    },\n  ]),\n  (initial_state = {\n    origin: { translation: [0, 0, 0], rotation: [1, 0, 0, 0] },\n    joints: { panda_joint1: 0.0, panda_joint2: 0.0 },\n  }), //only the origin and joints need to be defined for the state object for initial_state\n  (only_core = False), // Only use this flag if you are not using liveliness objectives and want a slight speed-up\n  (max_retries = 1), // Number of times the solution is attempted\n  (max_iterations = 150), // Number of iterations per try\n  (collision_settings = {\n    dMax: 0.3,\n    r: 0.0,\n    aMax: 2.0,\n    timeBudget: 100,\n    timed: true,\n  }) // if not provided, the solve will use the default values\n);\n'))),(0,r.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'from lively import Solver, PositionMatchObjective, OrientationMatchObjective, SmoothnessMacroObjective, CollisionAvoidanceObjective, State, Transform, ScalarRange, BoxShape\nsolver = Solver(\n  urdf=\'<?xml version="1.0" ?><robot name="panda">...</robot>\', # Full urdf as a string\n  objectives={\n      "PositionMatchObjective" : PositionMatchObjective(name="EE Position",link="panda_hand",weight=50),\n      "OrientationMatchObjective" :  OrientationMatchObjective(name="EE Rotation",link="panda_hand",weight=25),\n      "SmoothnessMacroObjective":SmoothnessMacroObjective(name="General Smoothness",weight=10),\n      "CollisionAvoidanceObjective":CollisionAvoidanceObjective(name="Collision Avoidance",weight=10)\n      ...\n  },\n  root_bounds=[\n      ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0), # Translational, (x, y, z)\n      ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0)  # Rotational, (r, p, y)\n  ],\n  shapes=[\n      BoxShape(name="Table",frame="world",physical=True,x=2,y=1,z=1.2,local_transform=Transform.isometry())\n  ],\n  initial_state=State(origin=Transform.identity(),joints={"panda_joint1":0.0,"panda_joint2":0.0,...}), # Optional\n  only_core=False, # Only use this flag if you are not using liveliness objectives and want a slight speed-up.\n  max_retries=1, # Number of times the solution is attempted (default 1)\n  max_iterations=150, # Number of iterations per try (default 150)\n  collision_settings = CollisionSettingInfo(\n      d_max = 0.3,\n      r = 0.0,\n      a_max = 2.0,\n      time_budget = 100,\n      timed = True))\n'))),(0,r.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use lively::lively::Solver;\nuse lively::objectives::core::base::CollisionAvoidanceObjective;\nuse lively::objectives::core::base::SmoothnessMacroObjective;\nuse lively::objectives::core::matching::PositionMatchObjective;\nuse lively::objectives::objective::Objective;\nuse lively::utils::goals::Goal;\nuse lively::utils::info::TransformInfo;\nuse lively::utils::shapes::*;\nuse std::fs;\n\nfn main(){\n let urdf_string =\n    fs::read_to_string("./ur3e.xml").expect("Something went wrong reading the file");\n let pos_match_obj =\n    PositionMatchObjective::new("EE Position".to_string(), 0.0, "tool0".to_string());\n let col_avoid_obj =\n    CollisionAvoidanceObjective::new("Collision Avoidance".to_string(), 20.0);\n let smooth_macro_obj = SmoothnessMacroObjective::new("Smoothness".to_string(), 30.0);\n let root_bounds: Vec<(f64, f64)> = vec![\n         (0.0, 0.0),\n         (0.0, 0.0),\n         (0.0, 0.0),\n         (0.0, 0.0),\n         (0.0, 0.0),\n         (0.0, 0.0),\n     ];\n let iso_1 = Isometry3::from_parts(\n         Translation3::new(\n             0.6497281999999998,\n             -0.24972819999999987,\n             0.050000000000000044,\n         ),\n         UnitQuaternion::from_quaternion(Quaternion::new(\n             0.0,\n             0.0,\n             -0.7069999677447771,\n             0.7072135784958345,\n         )),\n     );\n let box_1 = Shape::Box(BoxShape::new(\n         "box".to_string(),\n         "world".to_string(),\n         true,\n         0.5,\n         0.75,\n         0.5,\n         iso_1,\n     ));\n let iso_2 = Isometry3::from_parts(\n         Translation3::new(\n             -0.7,\n             -0.44972819999999987,\n             -0.050000000000000044,\n         ),\n         UnitQuaternion::from_quaternion(Quaternion::new(\n             0.0,\n             0.0,\n             -0.7069999677447771,\n             0.7072135784958345,\n         )),\n     );\n let sphere_1 = Shape::Sphere(SphereShape::new(\n             "sphere".to_string(),\n             "world".to_string(),\n             true,\n             0.25,\n             iso_2,\n         ));\n let mut solver = Solver::new(\n         urdf_string,\n         objectives,\n         Some(root_bounds),\n         Some(vec![box_1,sphere_1]),\n         None, //initial_state\n         None, //max_retries\n         None, //max_iterations\n         None, //collision_settings\n     );\n}\n')))))}h.isMDXComponent=!0}}]);
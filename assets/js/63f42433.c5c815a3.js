"use strict";(self.webpackChunklively_documentation=self.webpackChunklively_documentation||[]).push([[4056],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},b=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),f=c(t),b=i,d=f["".concat(s,".").concat(b)]||f[b]||p[b]||o;return t?a.createElement(d,l(l({ref:n},u),{},{components:t})):a.createElement(d,l({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=b;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[f]="string"==typeof e?e:i,l[1]=r;for(var c=2;c<o;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>l});var a=t(67294),i=t(86010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:t,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o.tabItem,l),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>_});var a=t(87462),i=t(67294),o=t(86010),l=t(12466),r=t(16550),s=t(91980),c=t(67392),u=t(50012);function f(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}function p(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??f(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function b(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function d(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(o),(0,i.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace({...a.location,search:n.toString()})}),[o,a])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=p(e),[l,r]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!b({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[s,c]=d({queryString:t,groupId:a}),[f,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,o]=(0,u.Nk)(t);return[a,(0,i.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),m=(()=>{const e=s??f;return b({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{m&&r(m)}),[m]);return{selectedValue:l,selectValue:(0,i.useCallback)((e=>{if(!b({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);r(e),c(e),g(e)}),[c,g,o]),tabValues:o}}var m=t(72389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function h(e){let{className:n,block:t,selectedValue:r,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:f}=(0,l.o5)(),p=e=>{const n=e.currentTarget,t=u.indexOf(n),a=c[t].value;a!==r&&(f(n),s(a))},b=e=>{let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}n?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:l}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,key:n,ref:e=>u.push(e),onKeyDown:b,onClick:p},l,{className:(0,o.Z)("tabs__item",v.tabItem,l?.className,{"tabs__item--active":r===n})}),t??n)})))}function y(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function j(e){const n=g(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",v.tabList)},i.createElement(h,(0,a.Z)({},e,n)),i.createElement(y,(0,a.Z)({},e,n)))}function _(e){const n=(0,m.Z)();return i.createElement(j,(0,a.Z)({key:String(n)},e))}},38950:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>f});var a=t(87462),i=(t(67294),t(3905)),o=t(74866),l=t(85162);const r={},s="Adding Goals",c={unversionedId:"Tutorials/adding_goals",id:"Tutorials/adding_goals",title:"Adding Goals",description:"Since Lively is still in beta, the design is subject to change and should not be considered final!",source:"@site/docs/Tutorials/adding_goals.mdx",sourceDirName:"Tutorials",slug:"/Tutorials/adding_goals",permalink:"/lively/docs/Tutorials/adding_goals",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorials",previous:{title:"Adding Objectives",permalink:"/lively/docs/Tutorials/adding_objectives"}},u={},f=[],p={toc:f},b="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(b,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adding-goals"},"Adding Goals"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Since Lively is still in beta, the design is subject to change and should not be considered final!")),(0,i.kt)("p",null,"A developer may desire to create a lifelike behavior that exhibits positional and rotational motion around an offset ",(0,i.kt)("inlineCode",{parentName:"p"},"focal point"),",\nas if inspecting the properties of an object located there. Doing so\nrequires the addition of an new ",(0,i.kt)("a",{parentName:"p",href:"/lively/docs/API/Goals/goal"},(0,i.kt)("inlineCode",{parentName:"a"},"goal"))," type, which would encode the\n",(0,i.kt)("inlineCode",{parentName:"p"},"focal length")," to maintain the position of the focus, and the amount\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"rotational/translational")," movement allowed. The ",(0,i.kt)("a",{parentName:"p",href:"../API/Objectives/"},(0,i.kt)("inlineCode",{parentName:"a"},"objective\u2019s"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"\ud835\udc50\ud835\udc4e\ud835\udc59\ud835\udc59"),"\nmethod would use these goals and a Perlin noise generator function\nto project the needed position and orientation in space to achieve\nthe specified rotation around the focus at a given time and compute\nthe radial and translational distance from those values, returning a\ncost value. The resulting ",(0,i.kt)("a",{parentName:"p",href:"../API/Objectives/"},(0,i.kt)("inlineCode",{parentName:"a"},"objective"))," would attempt to produce poses\nthat adhered to this dynamic pattern as a function of time."),(0,i.kt)("p",null,"To demonstrate how to create additional lifelike behavior mentioned above, the developer will have to makes changes to the following files:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Wisc-HCI/lively/blob/master/src/objectives/liveliness/perlin.rs"},(0,i.kt)("inlineCode",{parentName:"a"},"src/objectives/liveliness/perlin.rs"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Wisc-HCI/lively/blob/master/src/objectives/objective.rs"},(0,i.kt)("inlineCode",{parentName:"a"},"src/objectives/objective.rs"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Wisc-HCI/lively/blob/master/src/utils/goals.rs"},(0,i.kt)("inlineCode",{parentName:"a"},"src/utils/goals.rs"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Wisc-HCI/lively/blob/master/src/utils/info.rs"},(0,i.kt)("inlineCode",{parentName:"a"},"src/utils/info.rs")))),(0,i.kt)("p",null,"We will name the new objective: ",(0,i.kt)("inlineCode",{parentName:"p"},"PerspectiveLivelinessObjective")," and the new goal: ",(0,i.kt)("inlineCode",{parentName:"p"},"Cone"),"."),(0,i.kt)(o.Z,{mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"perlin",label:"src/objectives/liveliness/perlin.rs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    ...\n    [repr(C)]\n    #[derive(Serialize, Deserialize, Clone, Debug, Default)] #[cfg_attr(feature = "pybindings", pyclass)]\n    pub struct PerspectiveLivelinessObjective {\n        // Adds position liveliness to the specified link\n        pub name: String,\n        pub weight: f64,\n        pub link: String,\n        pub frequency: f64,\n\n        // Goal Value (shape of noise)\n        #[serde(skip)]\n        pub goal: Cone,\n        #[serde(skip)]\n        pub time: Option<f64>,\n\n        // Inaccessible\n        #[serde(skip)]\n        pub noise: Vector3<f64>,\n        #[serde(skip, default = "get_default_perlin")]\n        pub perlin: Perlin,\n        #[serde(skip, default = "get_default_offsets")]\n        pub offsets: [f64; 3],\n    }\n\n    impl PerspectiveLivelinessObjective {\n        pub fn new(name: String, weight: f64, link: String, frequency: f64) -> Self {\n            let mut rng: ThreadRng = thread_rng();\n            let seed: u32 = rng.gen();\n            let perlin: Perlin = Perlin::new().set_seed(seed);\n            let offsets: [f64; 3] = [\n            f64::from(rng.gen_range(0..1000)),\n            f64::from(rng.gen_range(0..1000)),\n            f64::from(rng.gen_range(0..1000)),\n            ];\n        Self {\n            name,\n            weight,\n            link,\n            frequency,\n            goal: Cone::default(),\n            time: None,\n            noise: vector![0.0, 0.0, 0.0],\n            perlin,\n            offsets,\n            }\n        }\n    }\n\n    impl Callable<Cone> for PerspectiveLivelinessObjective {\n        fn call(&self, v: &Vars, state: &State) -> f64 {\n            //implementation ommitted\n            ...\n            return ;\n         }\n\n        fn update(&mut self, time: f64) {\n            //implementation ommitted\n        }\n\n        fn set_goal(&mut self, goal: Cone) {\n            self.goal = goal;\n        }\n\n        fn set_weight(&mut self, weight: f64) {\n            self.weight = weight;\n        }\n    }\n\n    #[cfg(feature = "pybindings")]\n    #[pymethods]\n    impl PerspectiveLivelinessObjective {\n        #[new]\n        pub fn from_python(name:String,weight:f64,link:String,frequency:f64) -> Self {\n            PerspectiveLivelinessObjective::new(name,weight,link,frequency)\n        }\n\n        #[getter]\n        pub fn get_name(&self) -> PyResult<String> {\n            Ok(self.name.clone())\n        }\n\n        #[getter]\n        pub fn get_weight(&self) -> PyResult<f64> {\n            Ok(self.weight.clone())\n        }\n\n        #[getter]\n        pub fn get_link(&self) -> PyResult<String> {\n            Ok(self.link.clone())\n        }\n\n        #[getter]\n        pub fn get_frequency(&self) -> PyResult<f64> {\n            Ok(self.frequency.clone())\n        }\n    }\n    ...\n'))),(0,i.kt)(l.Z,{value:"objective",label:"src/objectives/objective.rs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    pub enum Objective {\n        ...\n        LinkVelocityMinimization(LinkVelocityMinimizationObjective),\n        LinkAccelerationMinimization(LinkAccelerationMinimizationObjective),\n        LinkJerkMinimization(LinkJerkMinimizationObjective),\n        RelativeMotionLiveliness(RelativeMotionLivelinessObjective),\n        //The additional objectives (PerspectiveLivelinessObjective)\n        PerspectiveLiveliness(PerspectiveLivelinessObjective),\n        //--------------------------------------------------\n        Gravity(GravityObjective),\n        ...\n    }\n\n    impl Objective {\n        pub fn get_type(&self) -> String {\n            // Returns a string value for each variant. Useful in debugging.\n            match self {\n                ...\n                Self::Gravity(_obj) => return String::from("GravityObjective"),\n                Self::SmoothnessMacro(_obj) => return String::from("SmoothnessMacroObjective"),\n                Self::DistanceMatch(_obj) => return String::from("DistanceMatchObjective"),\n                //The additional objectives (PerspectiveLivelinessObjective)\n                Self::PerspectiveLiveliness(_obj) => return String::from("PerspectiveLivelinessObjective")\n                //---------------------------------------------------------\n            }\n        }\n\n        pub fn call(&self,v: &Vars,state: &State) -> f64 {\n            // A switch that passes along the `call` method to the inner objective.\n            match self {\n                ...\n                Self::Gravity(obj) => obj.call(v,state),\n                Self::SmoothnessMacro(obj) => obj.call(v,state),\n                Self::DistanceMatch(obj) => obj.call(v,state),\n                //The additional objectives (PerspectiveLivelinessObjective)\n                Self::PerspectiveLiveliness(obj) => obj.call(v,state)\n                //---------------------------------------------------\n            }\n        }\n\n        pub fn update(&mut self, time: f64) {\n            // For time-sensitive objectives, include them here.\n            match self {\n                Self::PositionLiveliness(obj) => obj.update(time),\n                Self::OrientationLiveliness(obj) => obj.update(time),\n                Self::JointLiveliness(obj) => obj.update(time),\n                Self::RelativeMotionLiveliness(obj) => obj.update(time),\n                //The additional objectives (PerspectiveLivelinessObjective)\n                Self::PerspectiveLiveliness(obj) => obj.update(time),\n                //--------------------------------------------------\n                _ => {}\n            }\n        }\n\n        pub fn set_weight(&mut self, weight: f64) {\n            // Set the weight for the inner objective\n            match self {\n                ...\n                Self::Gravity(obj) => obj.set_weight(weight),\n                Self::SmoothnessMacro(obj) => obj.set_weight(weight),\n                Self::DistanceMatch(obj) =>  obj.set_weight(weight),\n                //The additional objectives (PerspectiveLivelinessObjective)\n                Self::PerspectiveLiveliness(obj) => obj.set_weight(weight)\n                //--------------------------------------------------------\n            }\n        }\n\n        pub fn get_goal(&self) -> Option<Goal> {\n            // get the goal for the inner objective. Useful for debugging.\n            match self {\n                ...\n                Self::Gravity(_obj) => return None,\n                Self::SmoothnessMacro(_obj) => return None,\n                Self::DistanceMatch(obj) => return Some(Goal::Scalar(obj.goal)),\n                //The additional objectives (PerspectiveLivelinessObjective)\n                Self::PerspectiveLiveliness(obj) => return Some(Goal::Cone(obj.goal))\n                //-------------------------------------------------------------------\n            }\n        }\n\n        pub fn set_goal(&mut self, goal: &Goal) {\n            // Set the goal for the inner objective. This matches based on Objective and Goal variant.\n            match (goal,self) {\n                ...\n                (Goal::Ellipse(ellipse_goal),Self::PositionBounding(obj)) => obj.set_goal(*ellipse_goal),\n                (Goal::RotationRange(rotation_range_goal),Self::OrientationBounding(obj)) => obj.set_goal(*rotation_range_goal),\n                (Goal::ScalarRange(scalar_range_goal),Self::JointBounding(obj)) => obj.set_goal(*scalar_range_goal),\n                //The additional goal (Cone) and objectives (PerspectiveLivelinessObjective)\n                (Goal::Cone(cone_goal), Self::PerspectiveLiveliness(obj)) => obj.set_goal(*cone_goal),\n                //-----------------------------------------------------------------------------------\n                (g,o) => {\n                    println!("Unexpected goal {:?} provided for Objective {:?}",g,o.clone())\n                }\n            }\n        }\n    }\n\n\n    #[cfg(feature = "pybindings")]\n    impl IntoPy<PyObject> for Objective {\n        fn into_py(self, py: Python) -> PyObject {\n            match self {\n                ...\n                Self::Gravity(obj) => obj.into_py(py),\n                Self::SmoothnessMacro(obj) => obj.into_py(py),\n                Self::DistanceMatch(obj) => obj.into_py(py),\n                //The additional objectives (PerspectiveLivelinessObjective) for python binding\n                Self::PerspectiveLiveliness(obj) => obj.into_py(py),\n                //-------------------------------------------------\n            }\n        }\n    }\n'))),(0,i.kt)(l.Z,{value:"goals",label:"src/utils/goals.rs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    ...\n    #[repr(C)]\n    #[derive(Serialize,Deserialize,Clone,Debug)]\n    pub enum Goal {\n        ...\n        RotationRange(RotationRange),\n        ScalarRange(ScalarRange),\n        //The additional goal (Cone)\n        Cone(Cone)\n        //--------\n    }\n\n    #[cfg(feature = "pybindings")]\n    impl IntoPy<PyObject> for Goal {\n        fn into_py(self, py: Python) -> PyObject {\n            match self {\n                ...\n                Self::RotationRange(obj) => obj.into_py(py),\n                Self::ScalarRange(obj) => obj.into_py(py),\n                //The additional goal (Cone)\n                Self::Cone(obj) => obj.into_py(py)\n                //-----------------------------\n            }\n        }\n    }\n\n    #[cfg(feature = "pybindings")]\n    impl FromPyObject<\'_> for Goal {\n        fn extract(ob: &\'_ PyAny) -> PyResult<Self> {\n            ...\n            if let Ok(ob) = ScalarRange::extract(ob) {\n                return Ok(Self::ScalarRange(ob))\n            }\n            //The additional goal (Cone)\n            if let Ok(ob) = Cone::extract(ob){\n                return Ok(Self::Cone(ob))\n            }\n            //-------------------------------\n\n\n            return Ok(Self::Scalar(0.0));\n        }\n    }\n    ...\n'))),(0,i.kt)(l.Z,{value:"info",label:"src/utils/info.rs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    ...\n    //The additional struct for the new goal (Cone)\n    #[repr(C)]\n    #[derive(Serialize, Deserialize, Clone, Debug, Default, Copy)]\n    #[cfg_attr(feature = "pybindings", pyclass)]\n    pub struct Cone {\n        pub focal_point : Vector3<f64>,\n        pub focal_length : f64,\n        pub delta: f64,\n    }\n\n    impl Cone {\n        pub fn new(focal_point: Vector3<f64>, focal_length: f64,delta: f64) -> Self {\n            Self { focal_point,focal_length, delta }\n        }\n    }\n\n    #[cfg(feature = "pybindings")]\n    #[pymethods]\n    impl Cone {\n        #[new]\n        pub fn from_python(focal_point: PyPoint3, focal_length: f64, delta: f64) -> Self {\n            Self::new(focal_point.value, focal_length, delta)\n        }\n\n        fn as_str(&self) -> String {\n            format!("Cone: {{focal_point: {:?}, focal_length: {:?}, delta: {:?} }}",\n                self.focal_point,\n                self.focal_length,\n                self.delta\n            )\n        }\n\n        pub fn __str__(&self) -> PyResult<String> {\n            Ok(self.as_str())\n        }\n\n        pub fn __repr__(&self) -> PyResult<String> {\n            Ok(self.as_str())\n        }\n\n        #[getter]\n        pub fn get_focal_point(&self) -> PyResult<PyPoint3>{\n            Ok(PyPoint3{value: self.focal_point})\n        }\n\n        #[getter]\n        pub fn get_focal_length(&self) -> PyResult<f64>{\n            Ok(self.focal_length)\n        }\n\n        #[getter]\n        pub fn get_delta(&self) -> PyResult<f64>{\n            Ok(self.delta)\n        }\n    }\n    //--------------------------------------\n    ...\n')))))}d.isMDXComponent=!0}}]);
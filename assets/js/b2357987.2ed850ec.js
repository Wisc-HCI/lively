"use strict";(self.webpackChunklively_documentation=self.webpackChunklively_documentation||[]).push([[6046],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||f[m]||r;return n?o.createElement(h,a(a({ref:t},p),{},{components:n})):o.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},865:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var o=n(7462),i=(n(7294),n(3905));const r={},a="Collision",l={unversionedId:"API/collision",id:"API/collision",title:"Collision",description:"Lively implements the PROXIMA collision detection algorithm, which allows for time-efficient collision",source:"@site/docs/API/collision.mdx",sourceDirName:"API",slug:"/API/collision",permalink:"/docs/API/collision",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Forces",permalink:"/docs/API/Objectives/forces"}},s={},c=[{value:"References",id:"references",level:2}],p={toc:c};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"collision"},"Collision"),(0,i.kt)("p",null,"Lively implements the PROXIMA collision detection algorithm, which allows for time-efficient collision\nand proximity detection for robots ",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". The Collision Avoidance objective serves to utilize the data generated from this collision detection algorithm to prevent collisions. Lively employs a three-fold\napproach to handling modeling collision objects. "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The first is input from the URDF during the initialization of the solver. This specification allows for the inclusion of four default types of shapes: ",(0,i.kt)("a",{parentName:"p",href:"../API/Shapes/box"},(0,i.kt)("inlineCode",{parentName:"a"},"boxes")),",\n",(0,i.kt)("a",{parentName:"p",href:"../API/Shapes/capsule"},(0,i.kt)("inlineCode",{parentName:"a"},"capsules")),", ",(0,i.kt)("a",{parentName:"p",href:"../API/Shapes/cylinder"},(0,i.kt)("inlineCode",{parentName:"a"},"cylinders")),", and ",(0,i.kt)("a",{parentName:"p",href:"../API/Shapes/sphere"},(0,i.kt)("inlineCode",{parentName:"a"},"spheres")),", and these shapes are automatically imported into the collision model when the URDF is parsed. For cross-platform and web-based reasons, mesh-based colliders are ignored during URDF import. ")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The second approach allows additional\ncolliders to be specified during initialization, including the above\nshapes and additionally convex hulls. These shapes can be attached\nto any link in the robot, or the world, allowing for a second level\nof support for collision specification. ")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Finally, as an optional input\nto the ",(0,i.kt)("a",{parentName:"p",href:"../API/Solver/Methods/solve"},(0,i.kt)("inlineCode",{parentName:"a"},"solve"))," method, developers can provide a set of updates to\nthe collision model. Using an id-based approach, new colliders can\nbe added, and existing colliders can be moved or deleted. These\nmechanisms enable the system to respond in real-time to new or\nmoving objects in the scene."))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The output of collision detection is a set of ",(0,i.kt)("a",{parentName:"p",href:"../API/Info/proximityInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"ProximityInfo")),".\nChanging the position of the object in the environment will not change the ",(0,i.kt)("inlineCode",{parentName:"p"},"distance")," parameter from ",(0,i.kt)("a",{parentName:"p",href:"../API/Info/proximityInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"ProximityInfo"))," if the distance between that object and the robot is outside the collision detection distance parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"d_max")," specified in ",(0,i.kt)("a",{parentName:"p",href:"../API/Info/collisionSettingInfo"},(0,i.kt)("inlineCode",{parentName:"a"},"collisionSettingInfo")),".")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img alt",src:n(1456).Z,width:"828",height:"408"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Solve times for the UR3e, Panda, and Pepper robots,\nwith randomized locations of collider-shapes. Of\nnote, speed is largely unaffected by collider-shapes count.")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},'Rakita, Daniel, Bilge Mutlu, and Michael Gleicher. "PROXIMA: An Approach for Time or Accuracy Budgeted Collision Proximity Queries." Proceedings of Robotics: Science and Systems (RSS). 2022. ',(0,i.kt)("a",{parentName:"li",href:"http://www.roboticsproceedings.org/rss18/p043.pdf"},"http://www.roboticsproceedings.org/rss18/p043.pdf"),(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0},1456:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/collisionGraph-f9e9389e2b2da30dd4f0e0d8aa987dce.png"}}]);
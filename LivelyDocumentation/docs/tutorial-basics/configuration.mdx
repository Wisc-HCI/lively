---
sidebar_position: 1
---

# Configuring

Configuring of Lively is centered on the **Solver** class, which you can instantiate in the following ways:



import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';




  

<Tabs>
  <TabItem value="js" label="Javascript">

  ```js
  import {Solver} from "@people_and_robots/lively";
  let solver = new Solver(
    urdf = "<?xml version='1.0' ?><robot name='panda'>...</robot>", // Full urdf as a string
    objectives = {
            "eePosition": {
              type: "PositionMatch",
              name: "EE Position",
              link: attachmentLink,
              weight: 50,
            },
            "eeRotation": {
              type: "OrientationMatch",
              name: "EE Rotation",
              link: attachmentLink,
              weight: 25,
            },
            "collision": {
              type: "CollisionAvoidance",
              name: "Collision Avoidance",
              weight: COLLISION_WEIGHT,
            },
     },
    root_bounds = [
        { value: basePose.position.x, delta: 0.0 },
        { value: basePose.position.y, delta: 0.0 },
        { value: basePose.position.z, delta: 0.0 }, // Translational
        { value: baseEuler[0], delta: 0.0 },
        { value: baseEuler[1], delta: 0.0 },
        { value: baseEuler[2], delta: 0.0 }, // Rotational
      ],
    shapes = [{
        type:"Box", //can be 'Cylinder', 'Capsule', or 'Sphere'
        name:"camera attachment",
        frame: "panda_hand", // or 'world'
        physical: true,
        x:0.5,y:0.5,z:0.2,
        localTransform: {translation:[0.0,0.0,0.0],rotation:[0.0,0.0,0.0,1.0]} // [x, y, z, w] ordering for quaternion
    }],
    initial_state= {origin:{translation:[0,0,0],rotation:[1,0,0,0]},joints:{panda_joint1:0.0,panda_joint2:0.0}}, // Optional
    only_core=False, // Only use this flag if you are not using liveliness objectives and want a slight speed-up.
    max_retries=1, // Number of times the solution is attempted (default 1)
    max_iterations=150, // Number of iterations per try (default 150)
    collision_settings = {dMax : 0.3, r : 0.0, aMax : 2.0, timeBudget : 100, timed : true}
  );
  ```

  </TabItem>
  <TabItem value="py" label="Python">

  ```py
  from lively import Solver, PositionMatchObjective, OrientationMatchObjective, SmoothnessMacroObjective, CollisionAvoidanceObjective, State, Transform, ScalarRange, BoxShape
  solver = Solver(
    urdf='<?xml version="1.0" ?><robot name="panda">...</robot>', # Full urdf as a string
    objectives={
        "PositionMatchObjective" : PositionMatchObjective(name="EE Position",link="panda_hand",weight=50),
        "OrientationMatchObjective" :  OrientationMatchObjective(name="EE Rotation",link="panda_hand",weight=25),
        "SmoothnessMacroObjective":SmoothnessMacroObjective(name="General Smoothness",weight=10),
        "CollisionAvoidanceObjective":CollisionAvoidanceObjective(name="Collision Avoidance",weight=10)
        ...
    }, 
    root_bounds=[
        ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0), # Translational, (x, y, z)
        ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0),ScalarRange(value=0.0,delta=0.0)  # Rotational, (r, p, y)
    ],
    shapes=[
        BoxShape(name="Table",frame="world",physical=True,x=2,y=1,z=1.2,local_transform=Transform.isometry())
    ], 
    initial_state=State(origin=Transform.identity(),joints={"panda_joint1":0.0,"panda_joint2":0.0,...}), # Optional
    only_core=False, # Only use this flag if you are not using liveliness objectives and want a slight speed-up.
    max_retries=1, # Number of times the solution is attempted (default 1)
    max_iterations=150, # Number of iterations per try (default 150)
    collision_settings = CollisionSettingInfo(
        d_max = 0.3, 
        r = 0.0, 
        a_max = 2.0, 
        time_budget = 100, 
        timed = True))
  ```
   </TabItem>
   <TabItem value= "rust" label="Rust"> 

   ```rust
   use lively::lively::Solver;
   use lively::objectives::core::base::CollisionAvoidanceObjective;
   use lively::objectives::core::base::SmoothnessMacroObjective;
   use lively::objectives::core::matching::PositionMatchObjective;
   use lively::objectives::objective::Objective;
   use lively::utils::goals::Goal;
   use lively::utils::info::TransformInfo;
   use lively::utils::shapes::*;
   use std::fs;

   fn main(){
    let urdf_string =
       fs::read_to_string("./ur3e.xml").expect("Something went wrong reading the file");
    let pos_match_obj =
       PositionMatchObjective::new("EE Position".to_string(), 0.0, "tool0".to_string());
    let col_avoid_obj =
       CollisionAvoidanceObjective::new("Collision Avoidance".to_string(), 20.0);
    let smooth_macro_obj = SmoothnessMacroObjective::new("Smoothness".to_string(), 30.0);
    let root_bounds: Vec<(f64, f64)> = vec![
            (0.0, 0.0),
            (0.0, 0.0),
            (0.0, 0.0),
            (0.0, 0.0),
            (0.0, 0.0),
            (0.0, 0.0),
        ];
    let iso_1 = Isometry3::from_parts(
            Translation3::new(
                0.6497281999999998,
                -0.24972819999999987,
                0.050000000000000044,
            ),
            UnitQuaternion::from_quaternion(Quaternion::new(
                0.0,
                0.0,
                -0.7069999677447771,
                0.7072135784958345,
            )),
        );
    let box_1 = Shape::Box(BoxShape::new(
            "box".to_string(),
            "world".to_string(),
            true,
            0.5,
            0.75,
            0.5,
            iso_1,
        ));  
    let iso_2 = Isometry3::from_parts(
            Translation3::new(
                -0.7,
                -0.44972819999999987,
                -0.050000000000000044,
            ),
            UnitQuaternion::from_quaternion(Quaternion::new(
                0.0,
                0.0,
                -0.7069999677447771,
                0.7072135784958345,
            )),
        );
    let sphere_1 = Shape::Sphere(SphereShape::new(
                "sphere".to_string(),
                "world".to_string(),
                true,
                0.25,
                iso_2,
            ));
    let mut solver = Solver::new(
            urdf_string,
            objectives,
            Some(root_bounds),
            Some(vec![box_1,sphere_1]),
            None,
            Some(true),
            None,
            None,
            None,
        );
   }
   ``` 
   </TabItem>
</Tabs> 









